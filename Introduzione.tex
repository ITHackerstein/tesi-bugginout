% LTeX: language=it

\chapter*{Introduzione}
\label{chap:introduzione}

% Idee:
%  * Ispirazione dietro al nome (breve, se si riesce)
%  * La motivazione dietro al linguaggio
%  * Obiettivi del linguaggio
%  * Struttura della tesi

BugginOut \`e un linguaggio di programmazione \textit{general-purpose} transpilato in C++ scritto in C++ da zero. Nasce ispirandosi ad altri linguaggi di programmazione prendendone le funzionalit\`a ritenute pi\`u utile per crearne uno nuovo con l'obiettivo di essere semplice, moderno e facile da leggere.

% TODO: Inserisci qua l'ispirazione al nome

Nel capitolo \ref{chap:flusso-di-compilazione} si analizzano tutte le fasi che portano un programma scritto in BugginOut (solitamente un file con estensione \texttt{.bo}), in particolare:
\begin{itemize}
	\item nel paragrafo \ref{sec:analisi-lessicale} si esamina la prima fase di compilazione, ovvero l'analisi lessicale del codice che consiste nella trasformazione del programma (un insieme di caratteri) in un insieme di \textit{token}, la parte atomica di ogni programma;
	\item nel paragrafo \ref{sec:analisi-grammaticale} si esamina l'analisi grammaticale del codice, ovvero come l'insieme di \textit{token} prodotto dall'analisi lessicale viene trasformato in un \textit{AST} (\textit{Abstract Syntax Tree}), un albero che rappresenta la struttura di un programma (o una sua parte) senza, per\`o, le informazioni contestuali;
	\item nel paragrafo \ref{sec:analisi-semantica} si esamina l'analisi semantica del codice, ovvero come l'AST generato dall'analisi grammaticale viene arricchito con informazioni contestuali come, ad esempio, variabili e funzioni dichiarate e i tipi utilizzati nel programma;
	\item nel paragrafo \ref{sec:generazione-del-codice} si esamina la fase finale della compilazione, ovvero la generazione del codice C++ finale che viene poi compilato, da un compilatore C++ gi\`a esistente, nell'eseguibile finale del programma.
\end{itemize}
Nel capitolo \ref{chap:architettura-del-compilatore} si analizzano nel dettaglio le astrazioni utilizzate per realizzare il compilatore, tra cui:
\begin{itemize}
	\item il \texttt{Lexer}, il cui compito \`e generare dei \texttt{Token} su richiesta a partire da un programma;
	\item il \texttt{Parser}, il cui compito \`e generare un'\texttt{AST} ovvero una gerarchia di \texttt{Node}, la classe madre di ogni nodo dell'albero;
	\item il \texttt{Typechecker}, il cui compito \`e controllare il corretto utilizzo di tipi, variabili e funzioni nel programma per poi generare un \texttt{CheckedAST};
	\item il \texttt{Transpiler}, il cui compito \`e trasformare il \texttt{CheckedAST} nel codice C++ finale.
\end{itemize}
Come \`e possibile osservare, c'\`e una corrispondenza uno-a-uno tra ognuna di queste astrazioni e le fasi che verranno affrontate nel \ref{chap:flusso-di-compilazione}.

Nel capitolo \ref{chap:design-del-linguaggio} si analizzano le scelte progettuali fatte per il linguaggio, in particolare se ne analizzer\`a la sintassi, i tipi di dato disponibili e le strutture presenti per il controllo del flusso.

Nel capitolo \ref{chap:alcuni-esempi} si analizzano alcuni algoritmi implementati in BugginOut per dimostrare l'espressivit\`a e infine nel \ref{chap:conclusioni} si esaminano i limiti del linguaggio allo stato attuale, i possibili sviluppi futuri e si tirano le somme sul lavoro svolto.
